if (is.numeric(data_train[[col]]) && (type == "numeric" || type == "both")) {
# Create histograms
hist(data_train[[col]],
main = paste(col),
xlab = "",
col = "dodgerblue4")
# plot non-numeric columns
} else if (!is.numeric(data_train[[col]]) && (type == "categoric"
|| type == "both")) {
# Adjust x-axis label arrangement for specific cols
barplot(table(data_train[[col]]),
main = paste(col),
xlab = "",
col = "dodgerblue",
las = 2)
}
}
# Reset the plotting layout
par(mfrow = c(1, 1))
}
# Numeric hist
plot_hist(data = data_train ,type="numeric", n=3, m=2)
# Numeric hist
plot_hist(data = data_train ,type="categoric", n=3, m=2)
# Compute correlation matrix
# Convert Categorical Variables to Numeric Using Label Encoding
data_encoded <- data_train %>%
mutate(across(where(is.character), ~ as.numeric(factor(.))))
# Compute the correlation matrix
correlations <- cor(data_encoded)
# Check if 'precio.house.m2' exists
if ("precio.house.m2" %in% colnames(correlations)) {
# Extract the row corresponding to 'precio.house.m2'
price_per_sqm_corr <- correlations["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
} else {
stop("precio.house.m2 not found in correlation matrix.")
}
library(corrplot)
# Plot
corrplot(correlations, method = "circle", addCoef.col = "black", type = "upper",
order = "hclust", tl.col = "black", tl.srt = 45)
# Install and load necessary packages
library(reshape2)
library(ggplot2)
library(GGally) # This is required for ggpairs
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
melted_corr_mat <- melt(corr_mat)
# Plot correlation heatmap
ggplot(data = melted_corr_mat, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "black", size = 4)+
scale_fill_gradient(low = "white", high = "red") +
theme_minimal()
library(ggcorrplot)
p <- ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
ggsave("Matriz de correlaciones.jpg", plot = p, width = 10, height = 10, units = "in", dpi = 300)
# Pairplot using ggpairs
ggpairs(data_train[, numeric_column_names])
average_price_per_barrio <- data_train %>%
group_by(barrio) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_barrio, aes(x = reorder(barrio, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by Barrio",
x = "Barrio",
y = "Average Price per 2m") +
theme_minimal()
average_price_per_district <- data_train %>%
group_by(distrito) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_district, aes(x = reorder(distrito, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by District",
x = "District",
y = "Average Price per 2m") +
theme_minimal()
# creacion de una nueva variable
data_tr_new <- data_train
data_tr_new$sup.const<-NULL
library(geosphere)
centro <- c(-3.6946, 40.4190)  # Longitude, Latitude
data_tr_new$radio <- distHaversine(
cbind(data_tr_new$longitud, data_tr_new$latitud),
centro
)
data_tr_new$precio.house.m2 <- log(data_tr_new$precio.house.m2)
numeric_column_names <- names(data_tr_new)[sapply(data_tr_new, is.numeric)]
corr_mat <- round(cor(data_tr_new[, numeric_column_names]), 2)
ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
View(data_tr_new)
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
data_train <- read_excel("Data/data_train.xlsx")
#install.packages(c("ggplot2", "sf", "dplyr"))
# Load libraries
library(ggplot2)
library(sf)
library(dplyr)
library(GGally)
colnames(data_train)
# turn identifiers into strings to prevent errors
data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona ", "casco.historico", "M.30","comercial")] <- lapply(data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona", "casco.historico", "M.30","comercial")], as.character)
unique_counts <- data.frame(
Column = names(data_train),
Unique_Values = sapply(data_train, function(x) length(unique(x)))
)
unique_counts
summary(data_train)
plot_hist = function(data_train, type = "both", n, m) {
# Configure subplots
par(mfrow = c(n, m),mar = c(10, 4, 4, 1))
# Loop through columns
for (col in colnames(data_train)) {
# plot numeric columns
if (is.numeric(data_train[[col]]) && (type == "numeric" || type == "both")) {
# Create histograms
hist(data_train[[col]],
main = paste(col),
xlab = "",
col = "dodgerblue4")
# plot non-numeric columns
} else if (!is.numeric(data_train[[col]]) && (type == "categoric"
|| type == "both")) {
# Adjust x-axis label arrangement for specific cols
barplot(table(data_train[[col]]),
main = paste(col),
xlab = "",
col = "dodgerblue",
las = 2)
}
}
# Reset the plotting layout
par(mfrow = c(1, 1))
}
# Numeric hist
plot_hist(data = data_train ,type="numeric", n=3, m=2)
# Numeric hist
plot_hist(data = data_train ,type="categoric", n=3, m=2)
# Compute correlation matrix
# Convert Categorical Variables to Numeric Using Label Encoding
data_encoded <- data_train %>%
mutate(across(where(is.character), ~ as.numeric(factor(.))))
# Compute the correlation matrix
correlations <- cor(data_encoded)
# Check if 'precio.house.m2' exists
if ("precio.house.m2" %in% colnames(correlations)) {
# Extract the row corresponding to 'precio.house.m2'
price_per_sqm_corr <- correlations["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
} else {
stop("precio.house.m2 not found in correlation matrix.")
}
library(corrplot)
# Plot
corrplot(correlations, method = "circle", addCoef.col = "black", type = "upper",
order = "hclust", tl.col = "black", tl.srt = 45)
# Install and load necessary packages
library(reshape2)
library(ggplot2)
library(GGally) # This is required for ggpairs
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
melted_corr_mat <- melt(corr_mat)
# Plot correlation heatmap
ggplot(data = melted_corr_mat, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "black", size = 4)+
scale_fill_gradient(low = "white", high = "red") +
theme_minimal()
library(ggcorrplot)
p <- ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
ggsave("Matriz de correlaciones.jpg", plot = p, width = 10, height = 10, units = "in", dpi = 300)
# Pairplot using ggpairs
ggpairs(data_train[, numeric_column_names])
average_price_per_barrio <- data_train %>%
group_by(barrio) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_barrio, aes(x = reorder(barrio, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by Barrio",
x = "Barrio",
y = "Average Price per 2m") +
theme_minimal()
average_price_per_district <- data_train %>%
group_by(distrito) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_district, aes(x = reorder(distrito, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by District",
x = "District",
y = "Average Price per 2m") +
theme_minimal()
# creacion de una nueva variable
data_tr_new <- data_train
data_tr_new$sup.const<-NULL
library(geosphere)
centro <- c(-3.6946, 40.4190)  # Longitude, Latitude
data_tr_new$radio <- distHaversine(
cbind(data_tr_new$longitud, data_tr_new$latitud),
centro
)
# logarithmic objective
data_tr_new$log.precio.house.m2 <- log(data_tr_new$precio.house.m2)
numeric_column_names <- names(data_tr_new)[sapply(data_tr_new, is.numeric)]
corr_mat <- round(cor(data_tr_new[, numeric_column_names]), 2)
ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
setwd("C:/Users/Nicolas/Desktop/GitHub/uc3m_regression_competition")
write.csv(data_tr_new, file = "data_transformed.csv", row.names = FALSE)
eigen(matrix(c(1,0,1,0)))
eigen(matrix(c(1,0,1,0), ncol=2))
# Multicollinearity Analysis
if(!require(car)) install.packages("car")
library(car)
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- data[, numeric_column_names]
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(precio.house.m2 ~ ., data = data)
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
knitr::opts_chunk$set(echo = TRUE)
data_train <- read_excel("Data/data_train.xlsx")
library(readxl)
data_train <- read_excel("Data/data_train.xlsx")
multicollinearity_analysis(data_train)
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- data[, numeric_column_names]
print(X)
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(precio.house.m2 ~ ., data = data)
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- data[, numeric_column_names]
print(numeric_column_names)
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(precio.house.m2 ~ ., data = data)
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
multicollinearity_analysis(data_train)
data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona ", "casco.historico", "M.30","comercial")] <- lapply(data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona", "casco.historico", "M.30","comercial")], as.character)
multicollinearity_analysis(data_train)
data_new = initial_transformation(data_train)
initial_transformation <- function(data){
data_tr_new <- data
# Eliminate sup.const for collinearity reasons
data_tr_new$sup.const <- NULL
# Create the new variable radius
centro <- c(-3.6946, 40.4190)  # Longitude, Latitude of the
data_tr_new$radius <- distHaversine(
cbind(data_tr_new$longitud, data_tr_new$latitud),
centro
)
# Logarithmic objective variable
data_tr_new$log.precio.house.m2 <- log(data_tr_new$precio.house.m2)
data_tr_new$precio.house.m2 <- NULL # Eliminate the old variable
return(data_tr_new)
}
data_new = initial_transformation(data_train)
library(geosphere)
data_new = initial_transformation(data_train)
View(data_tr_new)
numeric_column_names <- names(data_train)[sapply(data, is.numeric)]
numeric_column_names
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
numeric_column_names
X <- data[, numeric_column_names]
X <- data_train[, numeric_column_names]
t(X)%*%X
X
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(precio.house.m2 ~ ., data = data)
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
X <- as.matrix(data_train[, numeric_column_names])
t(X)%*%X
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(precio.house.m2 ~ ., data = data)
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
multicollinearity_analysis(data_train)
lambda <- eigen(t(X)%*%X)$values
cn <- sqrt(max(lambda)/min(lambda))
cn
lambda
model <- lm(precio.house.m2 ~ ., data = data_train)
summary(model)
lm(precio.house.m2 ~ numeric_column_names, data = data)
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(precio.house.m2 ~ ., data = X)
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
multicollinearity_analysis(data_train)
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(precio.house.m2 ~ ., data = as.data.frame(X))
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
multicollinearity_analysis(data_train)
multicollinearity_analysis(data_new)
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
# VIF
model <- lm(log.precio.house.m2 ~ ., data = as.data.frame(X))
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cn, VIF = vif))
}
multicollinearity_analysis(data_new)
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
XX <- model.matrix(model)
# Calculate the condition number
cond_number <- kappa(XX, exact = TRUE)
# VIF
model <- lm(log.precio.house.m2 ~ ., data = as.data.frame(X))
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cnond_number VIF = vif))
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
XX <- model.matrix(model)
# Calculate the condition number
cond_number <- kappa(XX, exact = TRUE)
# VIF
model <- lm(log.precio.house.m2 ~ ., data = as.data.frame(X))
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cnond_number, VIF = vif))
}
multicollinearity_analysis(data_new)
multicollinearity_analysis <- function(data){
# Obtain the numeric 'section' of the data matrix
numeric_column_names <- names(data)[sapply(data, is.numeric)]
X <- as.matrix(data[, numeric_column_names])
# Condition number
lambda <- eigen(t(X)%*%X)$values # Eigenvalues
if (min(lambda) <= 10^{-5}){
cn <- Inf
} else{
cn <- sqrt(max(lambda)/min(lambda))
}
XX <- model.matrix(model)
# Calculate the condition number
cond_number <- kappa(XX, exact = TRUE)
# VIF
model <- lm(log.precio.house.m2 ~ ., data = as.data.frame(X))
vif <- vif(model)
# Return a list with the parameters
return(list(CN = cond_number, VIF = vif))
}
multicollinearity_analysis(data_new)
