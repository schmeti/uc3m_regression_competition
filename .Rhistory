ggplot(data = melted_corr_mat, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "black", size = 4)+
scale_fill_gradient(low = "white", high = "red") +
theme_minimal()
# Pairplot using ggpairs
ggpairs(data_train[, numeric_column_names])
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
data_train <- read_excel("Data/data_train.xlsx")
#install.packages(c("ggplot2", "sf", "dplyr"))
# Load libraries
library(ggplot2)
library(sf)
library(dplyr)
library(GGally)
colnames(data_train)
# turn identifiers into strings to prevent errors
data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona ", "casco.historico", "M.30","comercial")] <- lapply(data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona", "casco.historico", "M.30","comercial")], as.character)
unique_counts <- data.frame(
Column = names(data_train),
Unique_Values = sapply(data_train, function(x) length(unique(x)))
)
unique_counts
summary(data_train)
plot_hist = function(data_train, type = "both", n, m) {
# Configure subplots
par(mfrow = c(n, m),mar = c(10, 4, 4, 1))
# Loop through columns
for (col in colnames(data_train)) {
# plot numeric columns
if (is.numeric(data_train[[col]]) && (type == "numeric" || type == "both")) {
# Create histograms
hist(data_train[[col]],
main = paste(col),
xlab = "",
col = "dodgerblue4")
# plot non-numeric columns
} else if (!is.numeric(data_train[[col]]) && (type == "categoric"
|| type == "both")) {
# Adjust x-axis label arrangement for specific cols
barplot(table(data_train[[col]]),
main = paste(col),
xlab = "",
col = "dodgerblue",
las = 2)
}
}
# Reset the plotting layout
par(mfrow = c(1, 1))
}
# Numeric hist
plot_hist(data = data_train ,type="numeric", n=3, m=2)
# Numeric hist
plot_hist(data = data_train ,type="categoric", n=3, m=2)
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["price_per_sqm", ]
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["precio.house.m2", ]
# Convert to data frame for better readability (optional)
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Print the result
print(price_per_sqm_corr_df)
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
data_train <- read_excel("Data/data_train.xlsx")
#install.packages(c("ggplot2", "sf", "dplyr"))
# Load libraries
library(ggplot2)
library(sf)
library(dplyr)
library(GGally)
colnames(data_train)
# turn identifiers into strings to prevent errors
data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona ", "casco.historico", "M.30","comercial")] <- lapply(data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona", "casco.historico", "M.30","comercial")], as.character)
unique_counts <- data.frame(
Column = names(data_train),
Unique_Values = sapply(data_train, function(x) length(unique(x)))
)
unique_counts
summary(data_train)
plot_hist = function(data_train, type = "both", n, m) {
# Configure subplots
par(mfrow = c(n, m),mar = c(10, 4, 4, 1))
# Loop through columns
for (col in colnames(data_train)) {
# plot numeric columns
if (is.numeric(data_train[[col]]) && (type == "numeric" || type == "both")) {
# Create histograms
hist(data_train[[col]],
main = paste(col),
xlab = "",
col = "dodgerblue4")
# plot non-numeric columns
} else if (!is.numeric(data_train[[col]]) && (type == "categoric"
|| type == "both")) {
# Adjust x-axis label arrangement for specific cols
barplot(table(data_train[[col]]),
main = paste(col),
xlab = "",
col = "dodgerblue",
las = 2)
}
}
# Reset the plotting layout
par(mfrow = c(1, 1))
}
# Numeric hist
plot_hist(data = data_train ,type="numeric", n=3, m=2)
# Numeric hist
plot_hist(data = data_train ,type="categoric", n=3, m=2)
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["price_per_sqm", ]
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
# Extract the row corresponding to 'price_per_sqm'
price_per_sqm_corr <- corr_mat["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
data_train <- read_excel("Data/data_train.xlsx")
#install.packages(c("ggplot2", "sf", "dplyr"))
# Load libraries
library(ggplot2)
library(sf)
library(dplyr)
library(GGally)
colnames(data_train)
# turn identifiers into strings to prevent errors
data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona ", "casco.historico", "M.30","comercial")] <- lapply(data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona", "casco.historico", "M.30","comercial")], as.character)
unique_counts <- data.frame(
Column = names(data_train),
Unique_Values = sapply(data_train, function(x) length(unique(x)))
)
unique_counts
summary(data_train)
plot_hist = function(data_train, type = "both", n, m) {
# Configure subplots
par(mfrow = c(n, m),mar = c(10, 4, 4, 1))
# Loop through columns
for (col in colnames(data_train)) {
# plot numeric columns
if (is.numeric(data_train[[col]]) && (type == "numeric" || type == "both")) {
# Create histograms
hist(data_train[[col]],
main = paste(col),
xlab = "",
col = "dodgerblue4")
# plot non-numeric columns
} else if (!is.numeric(data_train[[col]]) && (type == "categoric"
|| type == "both")) {
# Adjust x-axis label arrangement for specific cols
barplot(table(data_train[[col]]),
main = paste(col),
xlab = "",
col = "dodgerblue",
las = 2)
}
}
# Reset the plotting layout
par(mfrow = c(1, 1))
}
# Numeric hist
plot_hist(data = data_train ,type="numeric", n=3, m=2)
# Numeric hist
plot_hist(data = data_train ,type="categoric", n=3, m=2)
# Compute correlation matrix
# Convert Categorical Variables to Numeric Using Label Encoding
data_encoded <- data_train %>%
mutate(across(where(is.character), ~ as.numeric(factor(.))))
# Compute the correlation matrix
correlations <- cor(data_encoded)
# Check if 'precio.house.m2' exists
if ("precio.house.m2" %in% colnames(correlations)) {
# Extract the row corresponding to 'precio.house.m2'
price_per_sqm_corr <- correlations["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
} else {
stop("precio.house.m2 not found in correlation matrix.")
}
library(corrplot)
# Plot
corrplot(correlations, method = "circle", addCoef.col = "black", type = "upper",
order = "hclust", tl.col = "black", tl.srt = 45)
# Install and load necessary packages
library(reshape2)
library(ggplot2)
library(GGally) # This is required for ggpairs
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
melted_corr_mat <- melt(corr_mat)
# Plot correlation heatmap
ggplot(data = melted_corr_mat, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "black", size = 4)+
scale_fill_gradient(low = "white", high = "red") +
theme_minimal()
library(ggcorrplot)
p <- ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
ggsave("Matriz de correlaciones.jpg", plot = p, width = 10, height = 10, units = "in", dpi = 300)
# Pairplot using ggpairs
ggpairs(data_train[, numeric_column_names])
average_price_per_barrio <- data_train %>%
group_by(barrio) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_barrio, aes(x = reorder(barrio, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by Barrio",
x = "Barrio",
y = "Average Price per 2m") +
theme_minimal()
average_price_per_district <- data_train %>%
group_by(distrito) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_district, aes(x = reorder(distrito, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by District",
x = "District",
y = "Average Price per 2m") +
theme_minimal()
# creacion de una nueva variable
data_tr_new <- data_train
data_tr_new$sup.const<-NULL
library(geosphere)
centro <- c(-3.6946, 40.4190)  # Longitude, Latitude
data_tr_new$radio <- distHaversine(
cbind(data_tr_new$longitud, data_tr_new$latitud),
centro
)
data_tr_new$precio.house.m2 <- log(data_tr_new$precio.house.m2)
numeric_column_names <- names(data_tr_new)[sapply(data_tr_new, is.numeric)]
corr_mat <- round(cor(data_tr_new[, numeric_column_names]), 2)
ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
View(data_tr_new)
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
data_train <- read_excel("Data/data_train.xlsx")
#install.packages(c("ggplot2", "sf", "dplyr"))
# Load libraries
library(ggplot2)
library(sf)
library(dplyr)
library(GGally)
colnames(data_train)
# turn identifiers into strings to prevent errors
data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona ", "casco.historico", "M.30","comercial")] <- lapply(data_train[, c("train_indices", "cod_barrio", "cod_distrito", "ref.hip.zona", "casco.historico", "M.30","comercial")], as.character)
unique_counts <- data.frame(
Column = names(data_train),
Unique_Values = sapply(data_train, function(x) length(unique(x)))
)
unique_counts
summary(data_train)
plot_hist = function(data_train, type = "both", n, m) {
# Configure subplots
par(mfrow = c(n, m),mar = c(10, 4, 4, 1))
# Loop through columns
for (col in colnames(data_train)) {
# plot numeric columns
if (is.numeric(data_train[[col]]) && (type == "numeric" || type == "both")) {
# Create histograms
hist(data_train[[col]],
main = paste(col),
xlab = "",
col = "dodgerblue4")
# plot non-numeric columns
} else if (!is.numeric(data_train[[col]]) && (type == "categoric"
|| type == "both")) {
# Adjust x-axis label arrangement for specific cols
barplot(table(data_train[[col]]),
main = paste(col),
xlab = "",
col = "dodgerblue",
las = 2)
}
}
# Reset the plotting layout
par(mfrow = c(1, 1))
}
# Numeric hist
plot_hist(data = data_train ,type="numeric", n=3, m=2)
# Numeric hist
plot_hist(data = data_train ,type="categoric", n=3, m=2)
# Compute correlation matrix
# Convert Categorical Variables to Numeric Using Label Encoding
data_encoded <- data_train %>%
mutate(across(where(is.character), ~ as.numeric(factor(.))))
# Compute the correlation matrix
correlations <- cor(data_encoded)
# Check if 'precio.house.m2' exists
if ("precio.house.m2" %in% colnames(correlations)) {
# Extract the row corresponding to 'precio.house.m2'
price_per_sqm_corr <- correlations["precio.house.m2", ]
# Convert to data frame for plotting
price_per_sqm_corr_df <- data.frame(
Variable = names(price_per_sqm_corr),
Correlation = price_per_sqm_corr
)
# Plot the correlations
library(ggplot2)
ggplot(price_per_sqm_corr_df, aes(x = reorder(Variable, Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() + # Flip coordinates for easier readability
theme_minimal() +
labs(
title = "Correlation with price_per_sqm",
x = "Variable",
y = "Correlation"
)
} else {
stop("precio.house.m2 not found in correlation matrix.")
}
library(corrplot)
# Plot
corrplot(correlations, method = "circle", addCoef.col = "black", type = "upper",
order = "hclust", tl.col = "black", tl.srt = 45)
# Install and load necessary packages
library(reshape2)
library(ggplot2)
library(GGally) # This is required for ggpairs
# Compute correlation matrix
numeric_column_names <- names(data_train)[sapply(data_train, is.numeric)]
corr_mat <- round(cor(data_train[, numeric_column_names]), 2)
melted_corr_mat <- melt(corr_mat)
# Plot correlation heatmap
ggplot(data = melted_corr_mat, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "black", size = 4)+
scale_fill_gradient(low = "white", high = "red") +
theme_minimal()
library(ggcorrplot)
p <- ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
ggsave("Matriz de correlaciones.jpg", plot = p, width = 10, height = 10, units = "in", dpi = 300)
# Pairplot using ggpairs
ggpairs(data_train[, numeric_column_names])
average_price_per_barrio <- data_train %>%
group_by(barrio) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_barrio, aes(x = reorder(barrio, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by Barrio",
x = "Barrio",
y = "Average Price per 2m") +
theme_minimal()
average_price_per_district <- data_train %>%
group_by(distrito) %>%
summarise(average_price = mean(`precio.house.m2`, na.rm = TRUE))
ggplot(average_price_per_district, aes(x = reorder(distrito, average_price), y = average_price)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +  # Flip coordinates for better readability if there are many barrios
labs(title = "Average Price per 2m by District",
x = "District",
y = "Average Price per 2m") +
theme_minimal()
# creacion de una nueva variable
data_tr_new <- data_train
data_tr_new$sup.const<-NULL
library(geosphere)
centro <- c(-3.6946, 40.4190)  # Longitude, Latitude
data_tr_new$radio <- distHaversine(
cbind(data_tr_new$longitud, data_tr_new$latitud),
centro
)
# logarithmic objective
data_tr_new$log.precio.house.m2 <- log(data_tr_new$precio.house.m2)
numeric_column_names <- names(data_tr_new)[sapply(data_tr_new, is.numeric)]
corr_mat <- round(cor(data_tr_new[, numeric_column_names]), 2)
ggcorrplot(corr_mat, title = "Matriz de correlaciones",ggtheme = ggplot2::theme_minimal(),
hc.order = TRUE) +
theme(axis.text.x = element_text(size = 7)) +
theme(axis.text.y = element_text(size = 7))
setwd("C:/Users/Nicolas/Desktop/GitHub/uc3m_regression_competition")
write.csv(data_tr_new, file = "data_transformed.csv", row.names = FALSE)
